"""This python script can automatically generate map files from other map files, given a set of rules. These rules are defined in readlines class structures. At the moment, it supports two possible options:

1. Generate NLO+1 parton subtraction terms from the NNLO RR and RV subtraction terms
2. Generate W boson subtraction terms from the Z case, automatically turning off lines with no limit

We can in principle extend this to support anything we desire. Pass these as options into the allparse class"""

import sys,os,shutil
import datetime 

def readfile(name):
    f = open(name,'r')
    text = f.readlines()
    f.close()
    return text

def writefile(name,lines):
    f = open(name,'w')
    for l in lines:
        f.writelines(l.rstrip()+'\n')
    f.close
    return 0

def checkline(line):
    """A simple routine for checking if the line is suitable for parsing"""
    line = line.strip()
    if len(line) == 0:
        return False
    if line[0] == '#':
        return False
    return True    

class readlinesW:
    def __init__(self,oldfilename):
        """Changes all Z subtraction terms to W, removing unnecessary lines"""
        self.count = 0
        self.tmpbuffer = []
        self.newlines = []
        self.buffer = False
        self.oldfilename = oldfilename
        self.newfilename = self.genfilename()     

    def genfilename(self):
        """Generates the new filename from the old one"""
        newfilename = self.oldfilename.replace('Z','W')
        return newfilename 
 
    def add(self,line):
        splitLine = line.split('*')

        if (line.count('(') < line.count(')') and self.buffer):# and 'expand' not in line: # DW 16/11/16 Allow Qexpand terms through during Z->W conversion. Not sure of need for expand check...
            self.buffer = False
        elif (line.count('(') > line.count(')') or self.buffer):# and 'expand' not in line: # DW 16/11/16 Allow Qexpand terms through during Z->W conversion. Not sure of need for expand check...
            # started a bracketed region, start filling the temp buffer
            self.tmpbuffer.append(line)
            self.buffer = True
        if not self.buffer:
            if 'f2' not in line and (len(splitLine) > 2 or line.count('(') != line.count(')')):
                self.count += 1
                self.parseline(splitLine)
            elif len(splitLine) == 1:
                self.header(line)
            self.tmpbuffer = [] 

    def parseline(self,splitLine):
        """Parses the splitLine to fix up the final id in cases where the block is split across multiple sections of the NNLO subtraction term"""
        # this routine will not work in the VV case because we start the line with "aX" as opposed to ending the line with it...
        for i in xrange(len(splitLine)):
            splitLine[i] = splitLine[i].replace('f1','')
            splitLine[i] = splitLine[i].replace('Z','W')
        line = self.remakeline(splitLine)
        for i in xrange(len(self.tmpbuffer)):
            newline = self.tmpbuffer[i]
            newsplitLine = newline.split('*')
            for j in xrange(len(newsplitLine)):
                newsplitLine[j] = newsplitLine[j].replace('f1','')
                newsplitLine[j] = newsplitLine[j].replace('Z','W')
            self.tmpbuffer[i] = self.remakeline(newsplitLine)

        
        self.newlines += self.tmpbuffer
        self.newlines.append(line) 

    def remakeline(self,splitLine):
        """Recombines the line together from the individual components"""
        line = ''
        for l in splitLine:
            line += l+'*'
        line = line[:-1] 
        return line

    def header(self,line):
        """Checks the header and makes necessary changes to the syntax"""

        line = line.replace('Z','W')
        self.newlines.append(line)
        
    def timestamp(self):
        """Adds a basic comment to indicate that this file has been autogenerated. This can be updated in the future if necessary"""
        now = datetime.datetime.now()
        date = str(now.day) + '/' + str(now.month) + '/' + str(now.year)
        lines = ['# This subtraction term has been autogenerated using makemap.py, W replacement']
        lines += ['# Original file: '+self.oldfilename]
        lines += ['# Date: '+date]
        lines += [' ']
        print(self.genfilename())
        self.newlines = [self.newlines[0]] + lines + self.newlines[1:]
        count = 0
        for i in xrange(len(self.newlines)):
            l = self.newlines[i]
            splitLine = l.split('*')
            first = splitLine[0].strip()
            last = splitLine[-1].strip()
            if (len(first) in [3,4,5]) and first[1] == 'a':
                count += 1
                splitLine[0] = first[:2]+str(count)
            elif (len(last) in [2,3,4]) and last[0] == 'a':
                count += 1
                splitLine[-1] = 'a'+str(count)
            self.newlines[i] = self.remakeline(splitLine)
        if count == 0:
            self.count = 0 # reset counter

class readlinesNLO:
    def __init__(self,oldfilename):
        """Checks to see if the line is NLO or part of the header """        
        self.allowedMEs = ['B2g0Z','Bt2g0Z','C0g0Z','D0g0Z','B2g0W','Bt2g0W','C0g0W','D0g0Wa','D0g0Wb']
        self.count = 0
        self.tmpbuffer = []
        self.newlines = []
        self.buffer = False
        self.oldfilename = oldfilename
        self.newfilename = self.genfilename()


    def genfilename(self):
        """Generates the new filename from the old one"""
        newfilename = self.oldfilename.replace('S.map','SNLO.map')
        newfilename = newfilename.replace('T.map','TNLO.map')
        return newfilename

    def add(self,line):
        splitLine = line.split('*')

        if (line.count('(') < line.count(')') and self.buffer) and 'expand' not in line:
            self.buffer = False
        elif (line.count('(') > line.count(')') or self.buffer) and 'expand' not in line:
            # started a bracketed region, start filling the temp buffer
            self.tmpbuffer.append(line)
            self.buffer = True


        if not self.buffer:
            if any(m in line for m in self.allowedMEs): # check if target matrix element is in the line
                self.count += 1
                self.parseline(splitLine)
            elif len(splitLine) == 1:
                self.header(line)
            self.tmpbuffer = []            
    
    def header(self,line):
        """Checks the header and makes necessary changes to the syntax"""
        for id in ['S','T']:
            line = line.replace(id+'(',id+'NLO(')
        self.newlines.append(line)

    def parseline(self,splitLine):
        """Parses the splitLine to fix up the final id in cases where the NLO block is split across multiple sections of the NNLO subtraction term"""
        jet = splitLine[-2]
        splitJet = jet.split('(')
        if splitJet[0][-2] != splitJet[0][-1]: # fix jet algorithm if necessary to have additional jet
            splitJet[0] = 'JET'+2*splitJet[0][-1]
        splitLine[-2] = splitJet[0]+'('+splitJet[1]
        splitLine[-1] = 'a'+str(self.count)
        line = self.remakeline(splitLine)
        self.newlines += self.tmpbuffer
        self.newlines.append(line)
        
    def remakeline(self,splitLine):
        """Recombines the line together from the individual components"""
        line = ''
        for l in splitLine:
            line += l+'*'
        line = line[:-1] 
        return line
        
    def timestamp(self):
        """Adds a basic comment to indicate that this file has been autogenerated. This can be updated in the future if necessary"""
        now = datetime.datetime.now()
        date = str(now.day) + '/' + str(now.month) + '/' + str(now.year)
        lines = ['# This subtraction term has been autogenerated using makemap.py, NLO terms generated']
        lines += ['# Original file: '+self.oldfilename]
        lines += ['# Date: '+date]
        lines += [' ']
        self.newlines = [self.newlines[0]] + lines + self.newlines[1:]
            

class fullparse:
    def __init__(self,id,olddir,newdir):
        """A class for managing the parsing of all the files in a given directory"""
        self.newmaps = []
        fullDir = os.listdir(olddir)
        if id == 1:
            mapList = [m for m in fullDir if (m.endswith('S.map') or m.endswith('T.map'))]
        elif id == 2:
            mapList = [m for m in fullDir if (m.endswith('.map'))]
        else:
            raise Exception('Invalid id in fullparse class: ', id)
        mapList = [m for m in mapList if "auto" not in m]
        if len(mapList) == 0:
            print "No maple files found in directory: ", directory
            exit()
        for m in mapList:
            lines = readfile(os.path.join(olddir,m))
            if id == 1:
                reader = readlinesNLO(m)
            elif id == 2:
                reader = readlinesW(m)
            skip = False # skip a merged line
            for i in xrange(len(lines)):
                if not skip:
                    l = lines[i]
                    if i != len(lines)-1:
                        nextL = lines[i+1]
                    else:
                        nextL = ' '
                    if nextL[0] == '*' or (len(l.strip()) > 0 and l.strip()[-1] == '*'):
                        l = l+nextL # merge the two lines in the case that they're actually the same
                        skip = True
                    if checkline(l): # passed parsing checks
                        reader.add(l)
                else:
                    skip = False
            reader.timestamp()
            if reader.count != 0:
                self.newmaps.append(reader)
        for m in self.newmaps:
            if m.count != 0:
                writefile(os.path.join(newdir,m.newfilename),m.newlines)

    def printmapleRR(self,iprocess):
        listmaps = [m for m in self.newmaps if 'S' in m.oldfilename and m.count != 0]
        self.printmaple(iprocess,listmaps)

    def printmapleRV(self,iprocess):
        listmaps = [m for m in self.newmaps if 'T' in m.oldfilename and m.count != 0]
        self.printmaple(iprocess,listmaps)   

    def printmapleVV(self,iprocess):
        listmaps = [m for m in self.newmaps if 'U' in m.oldfilename and m.count != 0]
        self.printmaple(iprocess,listmaps)
        
    def printmaple(self,iprocess,listmaps):
        """Prints the full list of real subtraction terms for maple routines"""
        for i in xrange(len(listmaps)):
            newname = listmaps[i].newfilename.split('.')[0]
            print 'elif(iproc='+str(i+1)+'+'+str(iprocess)+'00)then'
            print "  myname:=`"+newname+"`:"
    
    def printmakefile(self):
        """Prints the full list of autogenerated fortran code for compiling"""
        makestr = ''
        for m in self.newmaps:
            newname = m.newfilename.split('.')[0]
            fortname = 'auto'+newname+'.f'
            makestr += fortname+' '
        makestr = makestr[:-1]
        print makestr

class moddriver:
    def __init__(self,newmaps,olddir,newdir):
        """A class for automatically modifying the driver routines"""
        self.olddir = olddir
        self.newdir = newdir
        self.newmaps = newmaps
        self.copy()
        
    def copy(self):
        """Copies the files over and renames them accordingly"""
        oldfiles = [f for f in os.listdir(self.olddir) if (f.endswith('S.f') or f.endswith('T.f')) and 'auto' not in f]
        for f in oldfiles:
            oldfile = os.path.join(self.olddir,f)
            newfile = os.path.join(self.newdir,f.replace('.f','NLO.f'))
            shutil.copyfile(oldfile,newfile)
            self.modify(f,newfile)

    def modify(self,oldfile,newfile):
        """Modifies the driver files for the NLO result"""
        now = datetime.datetime.now()
        date = str(now.day) + '/' + str(now.month) + '/' + str(now.year)
        header =  ['c This driver routine has been autogenerated using makeNLO.py']
        header += ['c Original file: '+oldfile]
        header += ['c Date: '+date]
        header += [' ']
        lines = readfile(newfile)
        lines = header + lines
        currentFn = ''
        for i in xrange(len(lines)):
            l = lines[i]
            for id in ['S','T']:
                l = l.replace(id+'(',id+'NLO(')
            if 'function' in l:
                splitL = l.split(' ')
                for part in splitL:
                    if '(' in part:
                        currentFn = part.split('(')[0]
            elif len(l.split('=')) != 1:
                l = l.replace(currentFn[:-3],currentFn)
            lines[i] = l
        writefile(newfile,lines)


            
        
try:
    olddir,newdir = sys.argv[1:3]
except (IndexError, ValueError):
    print "Please provide a target directories to read and write to, example: "
    print "python makeNLO.py process/Z/ process/ZJJ/"
    exit()


allparse = fullparse(2,olddir,newdir)
#allparse = fullparse(1,olddir,newdir)
#allparse.printmapleRR(7)
#print 
#allparse.printmapleRV(7)
#print 
#allparse.printmapleVV(8)
#print 
#allparse.printmakefile()
#moddriver(allparse.newmaps,'../driver/process/WJ/','../driver/process/WJJ/')            

